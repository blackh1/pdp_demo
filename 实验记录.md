# 云数据实验报告

[toc]

## 相关信息

### 论文题目

EnclavePDP: A General Framework to Verify Data Integrity in Cloud Using Intel SGX

### 环境参数

由于本组成员使用的CPU有Intel的,也有AMD的,所以使用SGX的模拟工具来进行本次实验.附录中会介绍如何安装相关的SDK.

- 硬件环境
  - Intel i7-9750H 4 core
  - 内存 4GB
- 软件环境
  - VMware Workstation 16 Pro
  - Ubuntu 20.04 LTS

### 实验目的

1. 阅读论文,了解目前PDP方案的发展状况与前景.
2. 了解相关的PDP方案和特点.
3. 尝试更改现有的PDP方案.

## 背景

随着云存储服务的普及,远程验证云上外包数据的完整性对用户来说是一项挑战.现有的可证明数据占有(PDP)方案大多是

## 代码改写

本次实验参考PDP方案为[Ahmad1234567/provable-data-possession](https://github.com/Ahmad1234567/provable-data-possession.git)

首先我们要明白,Enclave中是不可以链接系统的动态库的,而且静态库要使用编译好的,例如SGXSSL等.而我们的参考代码中还有包含其他头文件,因此直接放入Enclave中是不可取的,而且也尝试过了,编译不过,会出很多问题.因此我们需要将原本的PDP方案代码进行简单更改.

- 生成可信静态库
  首先将pdp-measurements.c和pdp-s3.c去掉后缀,我们用不到这个文件.然后我们将剩下的除了pdp-app.c文件编译程.o文件,最后使用ar进行生成静态库

  ```bash
  gcc -c *.c
  rm pdp-app.o
  ar crv libpdp.a *.o
  ```

  即可得到一个叫libpdp.a的静态库文件,我们之后就可以将该文件放在app和enclave部分进行链接,当作可信静态库.

- 改写app/TestApp.cpp
  我们需要设置程序的入口,对相关参数进行简单的判断.而且在其中我们需要创建enclave返回量,所以需要将原来的switch结构更改为goto结构.

- 改写enclave/TestEnclave.cpp
  这里我们放ecall函数,所有需要可信环境运行的代码都要放在这里.在edl文件中设置public属性可以在TestApp.cpp中直接调用对应函数.

- 改写enclave/TestEnclave.edl
  设置可信函数和不可信函数,需要对我们使用的函数进行可信说明和不可信说明,例如传入指针则需要说明指针类型,in表示复制到enclave中,out表示在enclave中的变化会影响app,此外还有一个user_check属性,这表示指针内容由用户自行检查,在此我们使用该属性即可.

  ```edl
  enclave {
    
    from "sgx_tsgxssl.edl" import *;
    from "sgx_pthread.edl" import *;

    include "../app/pdp.h"
    untrusted {
        void uprint([in, string] const char *str);
        int pdp_tag_file([user_check] char *filepath, size_t filepath_len,[user_check] char *tagfilepath, size_t tagfilepath_len);
        
        PDP_challenge *pdp_challenge_file(unsigned int numfileblocks);
        
        PDP_proof *pdp_prove_file([user_check] char *filepath, size_t filepath_len,[user_check] char *tagfilepath, size_t tagfilepath_len,[user_check] PDP_challenge *challenge,[user_check] PDP_key *key);
      ...
    };

    trusted {
        public void test();
        public void ecall_verify([in,out] char **optarg,long st_size);
    };
  };
  ```

- 改写Makefile文件
  该文件原本最开始是`include ../buildenv.mk`的,但是我们并不想包含外部文件,所以可以将该行替换为如下内容:
  
  ```makefile
  SGX_SSL := /opt/intel/sgxssl
  export PACKAGE_LIB := $(SGX_SSL)/lib64/
  export PACKAGE_INC := $(SGX_SSL)/include/
  export SGX_SDK ?= /opt/intel/sgxsdk/
  export VCC := @$(CC)
  export VCXX := @$(CXX)
  export OS_ID=0
  export LINUX_SGX_BUILD ?= 0

  UBUNTU_CONFNAME:=/usr/include/x86_64-linux-gnu/bits/confname.h
  ifneq ("$(wildcard $(UBUNTU_CONFNAME))","")
    OS_ID=1
  else ifeq ($(origin NIX_STORE),environment)
    OS_ID=3
  else
    OS_ID=2
  endif
  ```

- 改写sgx_t.mk
  这里设置的是enclave中代码的编译链情况,例如先通过某些文件生成.c文件,然后编译某些文件成为.o文件,最后使用私钥进行签名防止更改等等操作.

- 改写sgx_u.mk
  这里是设置app中代码的编译链情况,同sgx_t.mk,只不过这里多了一步链接的过程,所以这里需要更改的东西比较多.以文件中的代码为例,需要添加包含的库路径,而且链接时也要包含库的内容,还需要更改部分设置.

代码已经上传到了GitHub上面,使用下面的命令即可下载代码.
```bash
git clone https://github.com/blackh1/pdp_demo.git
```
## 代码结构介绍

以安装好SGXSSL的示例代码为例,

```bash
.
├── app                         不可信区域
│   ├── TestApp.cpp
│   └── TestApp.h
├── enclave                     可信区域
│   ├── TestEnclave.config.xml
│   ├── TestEnclave.cpp         可信函数定义
│   ├── TestEnclave.edl         可信和不可信函数说明
│   ├── TestEnclave.h           可信函数头文件
│   ├── TestEnclave.lds
│   ├── TestEnclave_private.pem 签名私钥
│   └── tests                   自定义文件
│       ├── bn_conf.h
│       ├── bn_int.h
│       ├── bn_lcl.h
│       ├── bntest.c
│       ├── dhtest.c
│       ├── ecdhtest.c
│       ├── ecdhtest_cavs.h
│       ├── ecdsatest.c
│       ├── ectest.c
│       ├── e_os.h
│       ├── evp_smx.c
│       ├── missing_funcs.c
│       ├── rsa_test.c
│       ├── sha1test.c
│       ├── sha256t.c
│       ├── stdio_func.c
│       ├── threads.h
│       └── threadstest.c
├── Makefile                    整体makefile文件
├── sgx_t.mk                    可信区域makefile文件
└── sgx_u.mk                    不可信区域makefile文件
```

首先我们要更改app中的代码,因为整个程序的入口就在app的TestAPP.cpp中,所以我们可以将pdp-app.c的代码进行选择性的复制.其中生成密钥和生成tag可以放在app环境下运行,因为正常情况下,这两个过程是在客户端完成的,我们这里集合成了一个程序,所以不再进行区分(其实真想区分也可以)

其次,在该运行环境下,我们不能链接动态库,所以我们可以将我们的函数部分的代码编译成一个静态可信库,这样链接就不会有问题了.

- app/TestApp.cpp TestApp.h
  程序的入口代码,以及相关函数定义,或者ocall函数定义

- enclave/TestEnclave.cpp TestEnclave.h
  ecall函数的定义,以及相关声明

- enclave/TestEnclave.edl
  声明ocall函数定义以及ecall函数的定义,包括变量的类型,是否传入以及是否有影响,指针处理问题

- Makefile
  编译该项目的文件,包含相关设置以及可信SSL库的位置,由于有些设置是包含在上级目录中的buildenv.mk中,所以我们需要将其复制到该文件中.

- sgx_t.mk sgx_u.mk
  包含可信(t)和不可信(u)区域代码的编译情况,以及包含某些文件,我们也需要对其进行简单更改.


## 附录

### SGX相关安装

**环境设置**

首先对于Ubuntu20.04进行换源,以便于下载相关程序和依赖项,在此不再介绍,网上有详细讲解.

- 更新

将程序进行更新

```bash
sudo apt update
sudo apt upgrade
```

- 配置相关环境

安装相关依赖项

```bash
sudo apt-get update
sudo apt-get install libssl-dev libcurl4-openssl-dev libprotobuf-dev
sudo apt-get install build-enssential python
```

**安装SGX Driver**

- 检查相关需求(以下是Ubuntu)

```bash
dpkg-query -s linux-headers-$(uname -r)
sudo apt-get install linux-headers-$(uname -r)
```

- 下载Intel SGX Driver

以下是CSDN给出的安装方法

```bash
wget https://download.01.org/intel-sgx/sgx-linux/2.16/distro/ubuntu20.04-server/sgx_linux_x64_driver_2.11.054c9c4c.bin
chmod +x sgx_linux_x64_driver_2.11.054c9c4c.bin
./sgx_linux_x64_driver_2.11.054c9c4c.bin
```

以下是Intel官方给出的安装方法

首先使用git命令下载官方代码,然后使用make命令自行build.

```bash
git clone https://github.com/intel/linux-sgx-driver.git
cd linux-sgx-driver
make
sudo mkdir -p "/lib/modules/"`uname -r`"/kernel/drivers/intel/sgx"
sudo cp isgx.ko "/lib/modules/"`uname -r`"/kernel/drivers/intel/sgx"
sudo sh -c "cat /etc/modules | grep -Fxq isgx || echo isgx >> /etc/modules"
sudo /sbin/depmod
sudo /sbin/modprobe isgx
```

官方的卸载方法也写在这里

```bash
sudo /sbin/modprobe -r isgx
sudo rm -rf "/lib/modules/"`uname -r`"/kernel/drivers/intel/sgx"
sudo /sbin/depmod
sudo /bin/sed -i '/^isgx$/d' /etc/modules
```

最后可以使用`lsmod|grep isgx`来查看是否安装成功.

**安装SGX SDK**

首先安装相关的依赖工具

```bash
sudo apt-get install build-essential ocaml ocamlbuild automake autoconf libtool wget python-is-python3 libssl-dev git cmake perl
```

如果这步出现依赖问题,可以使用aptitude来解决.

```bash
sudo apt-get install aptitude
sudo aptitude install build-essential ocaml ocamlbuild automake autoconf libtool wget python-is-python3 libssl-dev git cmake perl
```

在解决方案中先选择n,然后选择Y即可.[可见这篇文章](https://www.jianshu.com/p/ce514e8738e1)

**安装SGX PSW(硬件不支持可以不装)**

```bash
sudo apt-get install libssl-dev libcurl4-openssl-dev protobuf-compiler libprotobuf-dev debhelper cmake reprepro unzip
```

下载相关资源

```bash
git clone https://github.com/intel/linux-sgx.git
cd linux-sgx && make preparation
```

运行该命令后会进行一系列的下载操作，只需要耐心等候,最终会出现以下字样,即可代表完成

![image](http://other-file.blackh1.top/%E4%BA%91%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/4.png)

然后我们将对应的工具复制到对应位置以便于之后的使用.

```bash
sudo cp external/toolset/ubuntu20.04/* /usr/local/bin
which ar as ld objcopy objdump ranlib
```

**Build SGX安装程序**

```bash
make sdk
make sdk_install_pkg
```

运行完以上命令后,就可以在`linux/installer/bin/`下面了,然后运行`./sgx_linux_x64_sdk_2.16.100.4.bin`就可以安装了

第二种方式:

```bash
wget https://download.01.org/intel-sgx/sgx-linux/2.16/distro/ubuntu20.04-server/sgx_linux_x64_sdk_2.16.100.4.bin
chmod +x sgx_linux_x64_sdk_2.16.100.4.bin
./sgx_linux_x64_sdk_2.16.100.4.bin
```

如果出现权限不足就使用sudo安装,或者更改/opt文件夹的权限.一定要安装在/opt/intel下,因为后面的SGXSSL默认配置makefile里面都是这个目录.如果更换安装位置,需要更改makefile文件内容,比较麻烦.

**安装SGX SSL**

首先下载相关源码.

```bash
wget https://github.com/intel/intel-sgx-ssl/archive/refs/tags/lin_2.16_1.1.1m_update.zip
unzip lin_2.16_1.1.1m_update.zip
cd intel-sgx-ssl-lin_2.16_1.1.1m_update/openssl_source
wget https://github.com/openssl/openssl/archive/refs/tags/OpenSSL_1_1_1m.tar.gz
tar -zxvf OpenSSL_1_1_1m.tar.gz
mv openssl-OpenSSL_1_1_1m openssl-1.1.1m
tar -zcf openssl-1.1.1m.tar.gz openssl-1.1.1m
cd ../Linux
make all test SGX_MODE=SIM
sudo make install
```

在test运行之后会有结果,显示一堆OK而且有各种测试说明成功.SGXSSL也会安装在`/opt/intel`下面

